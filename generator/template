package capchan

import "fmt"

type type_$TYPE struct {
	rs      int
	channel (chan $TYPE)
	users   []interface{}
}

type Type_$TYPE interface {
	Receive(interface{}) ($TYPE, bool)
	Send($TYPE, interface{})
	Join(interface{}, interface{})
	Close()
	Cap() int
	Len() int
}

func (c *type_$TYPE) Receive(ref interface{}) ($TYPE, bool) {
	valid := false
	fmt.Printf("[recv] ref= %p \n", ref)
	for _, user := range c.users {
		if user == ref {
			valid = true
		}
	}
	if c.rs <= 1 && valid { //receive from a send only capchan
		ret, ok := <-c.channel
		return ret, ok
	} else {
		panic("Cannot receive: not a user of the channel")
	}
}

func (c *type_$TYPE) Send(i $TYPE, ref interface{}) {
	valid := false
	fmt.Printf("[send] ref= %p \n", ref)
	for _, user := range c.users {
		if user == ref {
			valid = true
		}
	}
	if c.rs >= 1 && valid {
		c.channel <- i
	} else {
		panic("Cannot send: not a user of the channel")
	}
}

//join
func (c *type_$TYPE) Join(newuser interface{}, olduser interface{}) {
	flag := false
	for _, user := range c.users {
		if user == olduser {
			c.users = append(c.users, newuser)
			fmt.Printf("[join] newuser= %p \n", newuser)
			flag = true
			break
		}
	}
	if !flag {
		panic("Cannot join: not a user of the channel")
	}
}


func New_$TYPE(rs int, users []interface{}) Type_$TYPE {
	return &type_$TYPE{rs, make(chan $TYPE), users}
}

func (c *type_$TYPE) Cap() int {
	return cap(c.channel)
}

func (c *type_$TYPE) Len() int {
	return len(c.channel)
}

func (c *type_$TYPE) Close() {
	close(c.channel)
}
