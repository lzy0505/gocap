
/* Lexical Part */

newln           : '\n' ;
semic           : ';' ;

/* keywords */
kw_capchan      : 'c' 'a' 'p' 'c' 'h' 'a' 'n' ;
kw_chan         : 'c' 'h' 'a' 'n' ;
kw_const        : 'c' 'o' 'n' 's' 't' ;
kw_func         : 'f' 'u' 'n' 'c' ;
kw_import       : 'i' 'm' 'p' 'o' 'r' 't' ;
kw_interface    : 'i' 'n' 't' 'e' 'r' 'f' 'a' 'c' 'e' ;
kw_int          : 'i' 'n' 't' ;
kw_map          : 'm' 'a' 'p' ;
kw_make         : 'm' 'a' 'k' 'e' ;
kw_package      : 'p' 'a' 'c' 'k' 'a' 'g' 'e' ;
kw_string       : 's' 'r' 'i' 'n' 'g' ;
kw_struct       : 's' 't' 'r' 'u' 'c' 't' ;
kw_type         : 't' 'y' 'p' 'e' ;
kw_var          : 'v' 'a' 'r' ;

lparen      : '(' ;
rparen      : ')' ;
lbrack      : '[' ;
rbrack      : ']' ;
lcurl       : '{' ;
rcurl       : '}' ;
dot         : '.' ;
comma       : ',' ;
ast         : '*' ;
larrow      : '<' '-' ;
llarrow     : '<' '-' '-' ;
assign      : ':' '=' ;
eq          : '=' ;

_idchars    : 'a'-'z' | 'A'-'Z' | '_' | '0'-'9' ;
id          : ('a'-'z' | 'A'-'Z' | '_') {_idchars} ;

/* string lits */
_escaped_char   : '\\' ( 'a' | 'b' | 'f' | 'n' | 'r' | 't' | 'v' | '\\' | '\'' | '`' ) ;
_raw_string     : '`' { . } '`' ;
_interp_string  : '"' { . | _escaped_char } '"' ;
string_lit      : _raw_string | _interp_string ;


!whitespace : ' ' | '\t' | '\r' ;

ignored     : . ;




/* Syntax Part */

<< import "github.com/nfk93/gocap/parser/simple/ast" >>


/* SOURCE FILE */
SourceFile    : NewLineOpts PackageClause ImportDecls TopLevelDecls  << ast.NewSourceFile($1, $2, $3) >> ;


/* TERMINATORS AND NEWLINES */
Terminators   : NewLineOpts Terminator NewLineOpts ;
Terminator        : newln | semic ;
NewLineOpts       : NewLineOpts newln | empty ;


/* PACKAGE */
PackageClause : kw_package id Terminators             << $1, nil >> ;


/* IMPORTS */
ImportDecls   : ImportDecls ImportDecl Terminators   << ast.AppendImportLists($0, $1) >>
              | empty                                << make([]ast.Import, 0), nil >> ;
ImportDecl    : kw_import ImportSpec                 << $1, nil >>
              | kw_import lparen ImportSpecs rparen  << $2, nil >> ;
ImportSpecs   : ImportSpecs ImportSpec Terminators                << ast.AppendImportLists($0, $1) >>
              | empty                                 << make([]ast.Import, 0), nil >> ;
ImportSpec    : dot ImportPath                       << ast.NewImport($1, true) >>
              | id ImportPath                          << ast.NewNamedImport($0, $1) >>
              | ImportPath                            << ast.NewImport($0, false) >> ;
ImportPath    : string_lit                            << $0, nil >> ;


/* TOP LEVEL DECLARATIONS */
TopLevelDecls   : TopLevelDecls TopLevelDecl Terminators         << ast.AppendCodeList($0, $1) >>
                | empty                               << (make([]ast.Code, 0)), nil >> ;
TopLevelDecl    : Declaration                         << $0, nil >>
                | FunctionDecl                        << $0, nil >>
                | MethodDecl                          << $0, nil >> ;


/* FUNCTION AND METHOD DECLARATION */
FunctionDecl    : kw_func id Signature FunctionBody           << ast.NewFunctionDecl($1, $2, $3) >> ;
MethodDecl      : kw_func Receiver id Signature FunctionBody  << ast.NewMethodDecl($1, $2, $3, $4) >> ;
FunctionBody    : Block                                       << $0, nil >>
                | empty                                       << ast.Unsupported("UNSUPPORTED: function declarations must be follow by a body") >> ;

Signature       : Parameters Result                 << ast.NewSignature($0, $1) >> ;
Result          : Type                              << $0, nil >>
                | lparen TypeList rparen            << $1, nil >>
                | Parameters                        << ast.Unsupported("UNSUPPORTED: identifiers in result type not supported") >>
                | empty                             << (make([]ast.Typ, 0)), nil >> ;

Parameters      : lparen ParameterList rparen       << $1, nil >> ;
ParameterList   : ParameterList NewLineOpts ParameterDecl       << ast.ConcatParameterLists($0, $2) >>
                | empty                             << (make([]ast.ParameterDecl, 0)), nil >> ;
ParameterDecl   : IdentifierList Type               << ast.MakeParameterDecl($0, $1) >>
                | IdentifierList "..." Type         << ast.Unsupported("UNSUPPORTED: variadic function arguments are not supported") >> ;


IdentifierList  : IdentifierList comma NewLineOpts id           << ast.AppendIdList($0, $3) >>
                | id                                << ast.NewIdList($0) >> ;

Receiver        : lparen id ast id rparen           << ast.NewPointerReceiver($1, $3) >>
                | lparen id id rparen               << ast.NewReceiver($1, $2) >> ;


/* CONST/VAR/TYPE DECLARATION */
Declaration     : ConstDecl                         << $0, nil >>
                | VarDecl                           << $0, nil >>
                | TypeDecl                          << $0, nil >> ;

ConstDecl       : empty << nil, nil >> ;
VarDecl         : empty << nil, nil >> ;
TypeDecl        : empty << nil, nil >> ;

Block           : lcurl BlockContents rcurl         << ast.NewBlock($1) >> ;
BlockContents   : BlockContents BlockContent        << ast.AppendCodeList($0, $1) >>
                | BlockContent                      << ast.NewBlockContentList($0) >> ;
BlockContent    : Block                             << $0, nil >>
                | ChannelExpr                       << $0, nil >>
                | Skip                              << $0, nil >> ;
 

/* CHANNEL EXPRESSIONS */
ChannelExpr     : ChannelMake | ChannelReceive | ChannelSend     << $0, nil >> ;

ChannelMake     : id assign kw_make lparen kw_capchan Type rparen     << ast.NewCapChanMake($0, $5) >>
                | id assign kw_make lparen kw_chan Type rparen        << ast.NewChanMake($0, $5) >>
                | id assign kw_make lparen kw_chan Type comma         << ast.Unsupported("UNSUPPORTED: buffered channels not supported") >> ;

ChannelReceive  : id assign llarrow id  << ast.NewCapChanReceive($0, $3) >> ;

ChannelSend     : id llarrow id     << ast.NewCapChanSend($0, $2) >> ;


/* TYPES */
TypeList        : TypeList comma NewLineOpts Type            << ast.AppendTypeList($0, $3) >>
                | Type                           << ast.NewTypeList($0) >> ;

Type            : lparen Type rparen          << $1, nil >>
                | StructType                  << $0, nil >>
                | PointerType                 << $0, nil >>
                | FunctionType                << $0, nil >>
                | InterfaceType               << $0, nil >>
                | SliceType                   << $0, nil >>
                | ChannelType                 << $0, nil >>
                | CapChannelType              << $0, nil >>
                | MapType                     << $0, nil >>
                | kw_int                      << ast.IntType{}, nil >>
                | kw_string                   << ast.StringType{}, nil >> ;

StructType      : kw_struct lcurl NewLineOpts FieldDecls rcurl      << ast.NewStructType($3) >>
                | kw_struct lcurl NewLineOpts rcurl                 << ast.NewStructType(make([]ast.StructField, 0)) >> ;
FieldDecls      : FieldDecls Terminators FieldDecl                  << ast.AppendStructFields($0, $2) >>
                | FieldDecl                                         << ast.NewStructFieldList($0) >> ;
FieldDecl       : IdentifierList Type                               << ast.MakeStructFields($0, $1) >> ;

PointerType     : ast Type << ast.NewPointerType($1) >> ;

FunctionType    : kw_func Signature << ast.NewFunctionType($1) >> ;

InterfaceType     : kw_interface lcurl NewLineOpts InterfaceMethods rcurl   << ast.NewInterfaceType($2) >>
                  | kw_interface lcurl NewLineOpts rcurl        << ast.NewInterfaceType(make([]ast.InterfaceMethod, 0)) >> ;
InterfaceMethods  : InterfaceMethods Terminators InterfaceMethod            << ast.AppendInterfaceMethodList($0, $2) >>
                  | InterfaceMethod                                       << ast.NewInterfaceMethodList($0) >> ;
InterfaceMethod   : id Signature                                << ast.NewInterfaceMethod($0, $1) >> ;

SliceType       : lbrack rbrack Type      << ast.NewSliceType($2) >> ;

MapType         : kw_map lbrack Type rbrack Type    << ast.NewMapType($2, $4) >> ;

ChannelType     : kw_chan Type            << ast.NewChannelType($1) >>
                  /* WARNING: this production must go before ROChans due to how R/R conflicts are handles */
                | kw_chan larrow Type     << ast.NewSOChannelType($2) >>
                | larrow kw_chan Type     << ast.NewROChannelType($2) >> ;

CapChannelType  : kw_capchan Type         << ast.NewCapChanType($1) >>
                  /* WARNING: this production must go before ROCapChans due to how R/R conflicts are handles */
                | kw_capchan llarrow Type << ast.NewSOCapChanType($2) >>
                | llarrow kw_capchan Type << ast.NewROCapChanType($2) >> ;


/* SKIP TOKEN */
Skip            : kw_capchan          << ast.SkipToken($0) >>
                | kw_chan             << ast.SkipToken($0) >>
                | kw_const            << ast.SkipToken($0) >>
                | kw_func             << ast.SkipToken($0) >>
                | kw_import           << ast.SkipToken($0) >>
                | kw_interface        << ast.SkipToken($0) >>
                | kw_map              << ast.SkipToken($0) >>
                | kw_make             << ast.SkipToken($0) >>
                | kw_package          << ast.SkipToken($0) >>
                | kw_struct           << ast.SkipToken($0) >>
                | kw_type             << ast.SkipToken($0) >>
                | kw_var              << ast.SkipToken($0) >>
                | lparen              << ast.SkipToken($0) >>
                | rparen              << ast.SkipToken($0) >>
                | dot                 << ast.SkipToken($0) >>
                | id                  << ast.SkipId($0) >>
                | string_lit          << ast.SkipToken($0) >>
                | ignored             << ast.SkipToken($0) >>
                /*| terminator          << ast.SkipToken($0) >>*/
                | comma               << ast.SkipToken($0) >>
                | kw_int              << ast.SkipToken($0) >>
                | kw_string           << ast.SkipToken($0) >>
                | ast                 << ast.SkipToken($0) >>
                | lbrack              << ast.SkipToken($0) >>
                | rbrack              << ast.SkipToken($0) >>
                | lcurl               << ast.SkipToken($0) >>
                | rcurl               << ast.SkipToken($0) >>
                | larrow              << ast.SkipToken($0) >>
                | llarrow             << ast.SkipToken($0) >>
                | eq                  << ast.SkipToken($0) >>
                | semic               << ast.SkipToken($0) >>
                | newln               << ast.SkipToken($0) >> ;
